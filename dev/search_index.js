var documenterSearchIndex = {"docs":
[{"location":"usage/#User-guide","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"usage/#Introduction","page":"User guide","title":"Introduction","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"We start off by giving some mathematical background, or rather by defining the needed language.","category":"page"},{"location":"usage/#Weakly-separated-Collections","page":"User guide","title":"Weakly separated Collections","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"For any integer n geq 1 we use the notation n= { 1 2 ldots n } and denote by textPot(kn) the set of k-subsets of n.","category":"page"},{"location":"usage/#Definition-(weak-separation)","page":"User guide","title":"Definition (weak separation)","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Let I J be k-subsets of n, then we call I and J textbfweakly separated if we cannot find elements a c in I setminus J and b d in J setminus I such that  (a b c d) is strictly cyclically ordered. In this case we write I parallel J. ","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Intuitively two k-subsets are weakly separated if after can arranging I setminus J and J setminus I clockwise on a circle, they can be separated by a line.","category":"page"},{"location":"usage/#Definition-(weakly-separated-collection)","page":"User guide","title":"Definition (weakly separated collection)","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"A subset mathcalC subseteq textPot(kn) is called a textbfweakly separated collection (abbreviated by WSC) if its elements are pairwise weakly separated.  We often referr to elements of a WSC as labels.","category":"page"},{"location":"usage/#Definition-(mutation)","page":"User guide","title":"Definition (mutation)","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"If mathcalC is a WSC that includes sets of the form Iab Ibc Icd Iad and Iac, where (abcd) is strictly cyclically ordered.  Then mathcalC = (mathcalC setminus Iac) cup Ibd is also a weakly separated collection, and we call the exchange of Iac by Ibd a textbfmutation.","category":"page"},{"location":"usage/#Plabic-Tilings","page":"User guide","title":"Plabic Tilings","text":"","category":"section"},{"location":"usage/#Definition-(plabic-tiling)","page":"User guide","title":"Definition (plabic tiling)","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Any WSC can be given the structure of an abstract 2-dimensional cell complex, which in turn may be embedded into the plane. This construction will be called an (abstract) textbfplabic tiling, and we referr to  TODO for the mathematical details.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Intuitively a plabic tiling is a tiling of a convex n-gon into convex polygons, colored either black or white, and with vertices labelled by the elements of the underlying WSC. Plabic tilings are in bijective correspondance with WSC's that are maximal with respect to inclusion.","category":"page"},{"location":"usage/#Plabic-Graphs","page":"User guide","title":"Plabic Graphs","text":"","category":"section"},{"location":"usage/#Definition-(plabic-graph)","page":"User guide","title":"Definition (plabic graph)","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"A textbfplabic graph is a finite simple connected plane graph G whose interior is bounded by a vertex disjoint cycle containing n textbfboundary vertices  b_1 ldots b_n. Here the labelling is chosen in clockwise order.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"We only consider textbfreduced plabic graphs which can be also seen to be in one to one correspondance to WSC's that are maximal with respect to inclusion.  For more details we referr to TODO.","category":"page"},{"location":"usage/#Creating-WSC's","page":"User guide","title":"Creating WSC's","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"compat: Vectors instead of sets\nIn this package we use vecors in place of sets, although WSC's are by definition sets of k-sets.  We always assume such vectors to be increasingly ordered and not contain double elements.  None of the below methods check these properties and unforseen behavior may arise if they are not fulfilled.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"The data type for WSC's or rather (abstract) plabic tilings is given by WSCollection.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"WSCollection","category":"page"},{"location":"usage/#WeaklySeparatedCollections.WSCollection","page":"User guide","title":"WeaklySeparatedCollections.WSCollection","text":"WSCollection\n\nAn abstract 2-dimensional cell complex living inside the matriod of k-sets in {1, ..., n}.  Its vertices are labelled by elements of labels while quiver encodes adjacencies  between the vertices.  The 2-cells are colored black or white and contained in blackCliques and whiteCliques.\n\nOptionally the 2-cells can be set to missing, to save memory.\n\nAttributes\n\nk::Int\nn::Int\nlabels::Vector{Vector{Int}}\nquiver::SimpleDiGraph{Int}\nwhiteCliques::Union{Missing, Dict{Vector{Int}, Vector{Int} }}\nblackCliques::Union{Missing, Dict{Vector{Int}, Vector{Int} }}\n\nConstructors\n\nWSCollection(k::Int, n::Int, labels::Vector{Vector{Int}}, computeCliques::Bool = true)\nWSCollection(k::Int, n::Int, labels::Vector{Vector{Int}}, quiver::SimpleDiGraph{Int}, \n                                                          computeCliques::Bool = true)\nWSCollection(collection::WSCollection; computeCliques::Bool = true)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Constructors","page":"User guide","title":"Constructors","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"There are three different constructors to create a WSC:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"WSCollection(k::Int, n::Int, labels::Vector{Vector{Int}}; computeCliques::Bool = true)\nWSCollection(k::Int, n::Int, labels::Vector{Vector{Int}}, quiver::SimpleDiGraph{Int}; computeCliques::Bool = true)\nWSCollection(collection::WSCollection; computeCliques::Bool = true)","category":"page"},{"location":"usage/#WeaklySeparatedCollections.WSCollection-Tuple{Int64, Int64, Vector{Vector{Int64}}}","page":"User guide","title":"WeaklySeparatedCollections.WSCollection","text":"WSCollection(k::Int, n::Int, labels::Vector{Vector{Int}}, computeCliques::Bool = true)\n\nConstructor of WSCollection. Adjacencies between its vertices as well as 2-cells are  computed using only a set of vertex labels.\n\nIf computeCliques is set to false, the 2-cells will be set to missing.\n\n\n\n\n\n","category":"method"},{"location":"usage/#WeaklySeparatedCollections.WSCollection-Tuple{Int64, Int64, Vector{Vector{Int64}}, SimpleDiGraph{Int64}}","page":"User guide","title":"WeaklySeparatedCollections.WSCollection","text":"WSCollection(k::Int, n::Int, labels::Vector{Vector{Int}}, quiver::SimpleDiGraph{Int}, \ncomputeCliques::Bool = true)\n\nConstructor of WSCollection. The 2-cells are computed from vertex labels as well as the their adjacencies encoded in quiver. Faster than just using labels most of the time.\n\nIf computeCliques is false the black and white 2-cells are set to missing instead.\n\n\n\n\n\n","category":"method"},{"location":"usage/#WeaklySeparatedCollections.WSCollection-Tuple{WSCollection}","page":"User guide","title":"WeaklySeparatedCollections.WSCollection","text":"WSCollection(collection::WSCollection; computeCliques::Bool = true)\n\nConstructor of WSCollection. Computes 2-cells of collection if the are missing,  othererwise returns a deepcopy of collection.\n\nIf computeCliques is false the black and white 2-cells are set to missing instead.\n\n\n\n\n\n","category":"method"},{"location":"usage/","page":"User guide","title":"User guide","text":"Thus to construct a WSC we only need to know its labels.","category":"page"},{"location":"usage/#Examples:","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nlabels = [[1, 5, 6], [1, 2, 6], [1, 2, 3], [2, 3, 4], [3, 4, 5], \n          [4, 5, 6], [2, 5, 6], [2, 3, 6], [3, 5, 6], [3, 4, 6] ]\nis_weakly_separated(6, labels) # checks for pairwise weak separation","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"C = WSCollection(3, 6, labels)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"However, if the underlying quiver is already known it can be passed to the constructor to speed up computations.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Q = C.quiver\nWSCollection(3, 6, labels, Q)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"The last constructor is useful, if we already have a WSC but want to omit the 2-cells or if the 2-cells of our WSC are missing and we want to compute them.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"D = WSCollection(C, computeCliques = false)\ncliques_missing(D) # checks if the cliques (i.e. the 2-cells) are missing","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"D = WSCollection(D)\nD.whiteCliques","category":"page"},{"location":"usage/#Extending-to-maximal-collections","page":"User guide","title":"Extending to maximal collections","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Sometimes we only want some maximal WSC containing one or more disired labels. To obtain such WSC's we simple add labels to our desired as long as possible.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"extend_weakly_separated!\nextend_to_collection","category":"page"},{"location":"usage/#WeaklySeparatedCollections.extend_weakly_separated!","page":"User guide","title":"WeaklySeparatedCollections.extend_weakly_separated!","text":"extend_weakly_separated!(k::Int, n::Int, labels::Vector{Vector{Int}})\n\nExtend labels to contain the labels of a maximal weakly separated collection.\n\n\n\n\n\nextend_weakly_separated!(k::Int, n::Int, labels1::Vector{Vector{Int}}, \n                                         labels2::Vector{Vector{Int}})\n\nExtend labels1 to contain the labels of a maximal weakly separated collection. Use elements of labels2 if possible.\n\n\n\n\n\nextend_weakly_separated!(labels::Vector{Vector{Int}}, collection::WSCollection)\n\nExtend labels to contain the labels of a maximal weakly separated collection. Use labels of collection if possible.\n\n\n\n\n\n","category":"function"},{"location":"usage/#WeaklySeparatedCollections.extend_to_collection","page":"User guide","title":"WeaklySeparatedCollections.extend_to_collection","text":"extend_to_collection(k::Int, n::Int, labels::Vector{Vector{Int}})\n\nReturn a maximal weakly separated collection containing all elements of labels.\n\n\n\n\n\nextend_to_collection(k::Int, n::Int, labels1::Vector{Vector{Int}}, \n                                     labels2::Vector{Vector{Int}})\n\nReturn a maximal weakly separated collection containing all elements of labels1. Use elements of labels2 if possible.\n\n\n\n\n\nextend_to_collection(labels::Vector{Vector{Int}}, collection::WSCollection)\n\nReturn a maximal weakly separated collection containing all elements of labels. Use labels of collection if possible.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-2","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"We may extend using brute force:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nlabel = [1, 3, 4]\nextend_weakly_separated!(3, 6, [label])","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Or if we want to prefer labels from a known weakly separated set (and then fill up by brute force):","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"label = [1, 3, 4]\npreferred_labels = [[1, 5, 6], [1, 2, 6], [1, 2, 3], [2, 3, 4], [3, 4, 5], \n                    [4, 5, 6], [2, 5, 6], [2, 3, 6], [3, 5, 6], [3, 4, 6]]\nextend_weakly_separated!(3, 6, [label], preferred_labels)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"We could have just as well passed a WSC instead of preferred_labels above. Note that so far we only constructed arrays of labels. To obtain a WSC containing these labels we use extend_to_collection.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"label = [1, 3, 4]\nextend_to_collection(3, 6, [label], preferred_labels)","category":"page"},{"location":"usage/#Predefined-collections","page":"User guide","title":"Predefined collections","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"We provide shortcuts for the construction of some well known WSC's:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"checkboard_collection\nrectangle_collection\ndual_checkboard_collection\ndual_rectangle_collection","category":"page"},{"location":"usage/#WeaklySeparatedCollections.checkboard_collection","page":"User guide","title":"WeaklySeparatedCollections.checkboard_collection","text":"checkboard_collection(k::Int, n::Int)\n\nReturn the weakly separated collection corresponding to the checkboard graph.\n\n\n\n\n\n","category":"function"},{"location":"usage/#WeaklySeparatedCollections.rectangle_collection","page":"User guide","title":"WeaklySeparatedCollections.rectangle_collection","text":"rectangle_collection(k::Int, n::Int)\n\nReturn the weakly separated collection corresponding to the rectangle graph.\n\n\n\n\n\n","category":"function"},{"location":"usage/#WeaklySeparatedCollections.dual_checkboard_collection","page":"User guide","title":"WeaklySeparatedCollections.dual_checkboard_collection","text":"dual_checkboard_collection(k::Int, n::Int)\n\nReturn the weakly separated collection corresponding to the dual-checkboard graph.\n\n\n\n\n\n","category":"function"},{"location":"usage/#WeaklySeparatedCollections.dual_rectangle_collection","page":"User guide","title":"WeaklySeparatedCollections.dual_rectangle_collection","text":"dual_rectangle_collection(k::Int, n::Int)\n\nReturn the weakly separated collection corresponding to the dual-rectangle graph.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-3","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nrectangle_collection(3, 6)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"If we only want the underlying labels we may instead use rectangle_labels(k::Int, n::Int) (similar for the other predefined collections).","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"rectangle_labels(3, 6)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"The labels of the rectangle collection can be arranged on a grid in a natural way. Specific labels in this grid are returned by rectangle_label(k::Int, n::Int, i::Int, j::Int) where i = 0  n-k and j = 0  k (similar for the other collections, where for the dual ones i = 0  k and j = 0  n-k ).","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"rectangle_label(3, 6, 1, 2)","category":"page"},{"location":"usage/#Basic-functionality","page":"User guide","title":"Basic functionality","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Armed with this plethora of examples, we are ready to discuss the basic functionalities of WSC's.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"WSC's behave in many ways as their underlying arrays of labels would. In particular labels may be accessed directly.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nrec = rectangle_collection(3, 6)\nrec[3]","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"rec[7] = [1, 3, 6]","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Caution is advised when modifying labels as above, as it is not checked if the resulting labels are still weakly separated nor is the associated data changed accordingly.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"For convenience we also extend the following functions:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"in\nlength\nintersect\nsetdiff\nunion","category":"page"},{"location":"usage/#Base.in","page":"User guide","title":"Base.in","text":"in(label::Vector{Int}, collection::WSCollection)\n\nReturn true if label is occurs as label of collection.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.length","page":"User guide","title":"Base.length","text":"length(collection::WSCollection)\n\nReturn the length of collection.labels.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.intersect","page":"User guide","title":"Base.intersect","text":"intersect(collection1::WSCollection, collection2::WSCollection)\n\nReturn the common labels of collection1 and collection2.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.setdiff","page":"User guide","title":"Base.setdiff","text":"setdiff(collection1::WSCollection, collection2::WSCollection)\n\nReturn the labels of collection1 minus the labels of collection2.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.union","page":"User guide","title":"Base.union","text":"setdiff(collection1::WSCollection, collection2::WSCollection)\n\nReturn the union of labels in collection1 and collection2.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-4","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nrec = rectangle_collection(3, 6)\ncheck = checkboard_collection(3, 6)\n\ncheck[10] in rec ","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"length(check)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"intersect(rec, check) # similar for union and setdiff","category":"page"},{"location":"usage/#Mutation","page":"User guide","title":"Mutation","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"WSC's usually contain frozen elements that never change. On the other hand some elements may be modified via mutation and are called mutable. To figure out which elements of a WSC are frozen or mutable use the functions is_frozen or is_mutable.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"is_frozen\nis_mutable","category":"page"},{"location":"usage/#WeaklySeparatedCollections.is_frozen","page":"User guide","title":"WeaklySeparatedCollections.is_frozen","text":"is_frozen(collection::WSCollection, i::Int)\n\nReturn true if the vertex i of collection is frozen.\n\n\n\n\n\n","category":"function"},{"location":"usage/#WeaklySeparatedCollections.is_mutable","page":"User guide","title":"WeaklySeparatedCollections.is_mutable","text":"is_mutable(collection::WSCollection, i::Int)\n\nReturn true if the vertex i of collection is mutable.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nrec = rectangle_collection(3, 6)\nis_frozen(rec, 4)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"rec = rectangle_collection(3, 6)\nis_mutable(rec, 7)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"rec = rectangle_collection(3, 6)\nis_mutable(rec, 11)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"The frozen labels contained in any (maximal) WSC can be obtained via","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"frozen_label\nfrozen_labels","category":"page"},{"location":"usage/#WeaklySeparatedCollections.frozen_label","page":"User guide","title":"WeaklySeparatedCollections.frozen_label","text":"frozen_label(k::Int, n::Int, i::Int)\n\nReturn the i-th frozen label.\n\n\n\n\n\n","category":"function"},{"location":"usage/#WeaklySeparatedCollections.frozen_labels","page":"User guide","title":"WeaklySeparatedCollections.frozen_labels","text":"frozen_labels(k::Int, n::Int)\n\nReturn the frozen labels as a vector.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"The indices of the mutable labels on a WSC can be obtained by using","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"get_mutables","category":"page"},{"location":"usage/#WeaklySeparatedCollections.get_mutables","page":"User guide","title":"WeaklySeparatedCollections.get_mutables","text":"get_mutables(collection::WSCollection)\n\nReturn all mutable vertices of collection.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"Finally, to mutate a WSC in the direction of a mutable label, the functions mutateand mutate! are available.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"mutate!\nmutate","category":"page"},{"location":"usage/#WeaklySeparatedCollections.mutate!","page":"User guide","title":"WeaklySeparatedCollections.mutate!","text":"mutate!(collection::WSCollection, i::Int, mutateCliques::Bool = true)\n\nMutate the collection in direction i if i is a mutable vertex of collection.\n\nIf mutateCliques is set to false, the 2-cells are set to missing.\n\n\n\n\n\nmutate!(collection::WSCollection, label::Vector{Int}, mutateCliques::Bool = true)\n\nMutate the collection by addressing a vertex with its label.\n\n\n\n\n\n","category":"function"},{"location":"usage/#WeaklySeparatedCollections.mutate","page":"User guide","title":"WeaklySeparatedCollections.mutate","text":"mutate(collection::WSCollection, i::Int, mutateCliques::Bool = true)\n\nVersion of mutate! that does not modify its arguments.\n\n\n\n\n\nmutate(collection::WSCollection, label::Vector{Int}, mutateCliques::Bool = true)\n\nMutate the collection by addressing a vertex with its label, without modifying arguments.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-5","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nrec = rectangle_collection(3, 6)\nget_mutables(rec)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"mutate!(rec, 7)\nprintln(rec, full = true)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"For convenience we may also mutate by specifying a label:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"mutate!(rec, [3,4,6])\nprintln(rec, full = true)","category":"page"},{"location":"usage/#Other-transformations","page":"User guide","title":"Other transformations","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Apart from mutation, several other transformations of WSC's are available:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"rotate!","category":"page"},{"location":"usage/#WeaklySeparatedCollections.rotate!","page":"User guide","title":"WeaklySeparatedCollections.rotate!","text":"rotate!(collection::WSCollection, amount::Int)\n\nRotate collection by amount, where a positive amount indicates a clockwise rotation.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"reflect!","category":"page"},{"location":"usage/#WeaklySeparatedCollections.reflect!","page":"User guide","title":"WeaklySeparatedCollections.reflect!","text":"reflect!(collection::WSCollection, axis::Int = 1)\n\nReflect collection by letting the permutation x ↦ 2*axis -x interpreted modulo  n = collection.n act on the labels of collection.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"complement!","category":"page"},{"location":"usage/#WeaklySeparatedCollections.complement!","page":"User guide","title":"WeaklySeparatedCollections.complement!","text":"complement!(collection::WSCollection)\n\nReturn the collection whose labels are complementary to those of collection.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"swap_colors!","category":"page"},{"location":"usage/#WeaklySeparatedCollections.swap_colors!","page":"User guide","title":"WeaklySeparatedCollections.swap_colors!","text":"swap_colors!(collection::WSCollection)\n\nReturn the weakly separated collection whose corresponding plabic graph is obtained from the one of collection by swapping the colors black and white.\n\nThis is the same as taking complements and rotating by collection.k.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"For each of the above methods, a variant that does not modify its argument is avaliable (just omit the ! ). ","category":"page"},{"location":"usage/#Examples:-6","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\ncheck = checkboard_collection(3, 6)\ncheck.labels","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\ncheck = checkboard_collection(3, 6)\nrotate!(check, 1)\ncheck.labels","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nreflect!(check, 1)\ncheck.labels","category":"page"},{"location":"usage/#Searching","page":"User guide","title":"Searching","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"In theory all WSC's of common type can be transformed into each other by mutations. In proctice however it is quite difficult to find a suitable sequence of mutations from one WSC to another. Thus we provide different searching algorithms to automate the search for such sequences.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"On the conceptually easy end we have breadth and depth first search:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"BFS","category":"page"},{"location":"usage/#WeaklySeparatedCollections.BFS","page":"User guide","title":"WeaklySeparatedCollections.BFS","text":"BFS(root::WSCollection, target::WSCollection)\n\nReturn a sequence of mutations, transforming root into target. This sequence is computed by a breadth first search. \n\nKeyword arguments:\n\nlimitSearchSpace::Bool = true\n\nIf limitSearchSpace is set to true then labels already contained in target will never be mutated.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"DFS","category":"page"},{"location":"usage/#WeaklySeparatedCollections.DFS","page":"User guide","title":"WeaklySeparatedCollections.DFS","text":"DFS(root::WSCollection, target::WSCollection)\n\nReturn a sequence of mutations, transforming root into target. This sequence is computed by a depth first search. \n\nKeyword arguments:\n\nlimitSearchSpace::Bool = true\n\nIf limitSearchSpace is set to true then labels already contained in target will never be mutated.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-7","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\ncheck = checkboard_collection(3, 7)\nrec = rectangle_collection(3, 7)\nBFS(check, rec)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"DFS(check, rec)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"If the target WSC is close enough, searching is also feasable for bigger parameters.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"check = checkboard_collection(7, 16)\nlabel = [1, 2, 3, 4, 5, 6, 15]\ntarget = extend_to_collection([label], check)\nDFS(check, target, limitSearchSpace = true)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"For more informed searching we first need suitable heuristics, i.e. lower bounds on the number of mutations needed to reach a WSC from a given one.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"number_wrong_labels","category":"page"},{"location":"usage/#WeaklySeparatedCollections.number_wrong_labels","page":"User guide","title":"WeaklySeparatedCollections.number_wrong_labels","text":"number_wrong_labels(collection::WSCollection, target::WSCollection)\n\nReturn the number of labels in collection that do not occur in target.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"min_label_dist","category":"page"},{"location":"usage/#WeaklySeparatedCollections.min_label_dist","page":"User guide","title":"WeaklySeparatedCollections.min_label_dist","text":"min_label_dist(collection::WSCollection, target::WSCollection)\n\nReturn the sum of minimum label distances, where for each label in collection  this distance is calculated as the minimal number of integer pairs one needs  to exchange in order to obtain a label of target.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"min_label_dist_experimental","category":"page"},{"location":"usage/#WeaklySeparatedCollections.min_label_dist_experimental","page":"User guide","title":"WeaklySeparatedCollections.min_label_dist_experimental","text":"min_label_dist_experimental(collection::WSCollection, target::WSCollection)\n\nReturn the sum over minimal label distances of wrong labels in collection. \n\nThis assumes that a minimal sequence of mutations between WSC's can be  found while never mutating correct labels i.e. labels that are contained  in the target WSC.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-8","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\ncheck = checkboard_collection(10, 20)\nrec = rectangle_collection(10, 20)\nnumber_wrong_labels(check, rec)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"min_label_dist(check, rec)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"min_label_dist_experimental(check, rec)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"The above heuristics can be used for the Astar algorithm by passing the corresponding enum.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Astar","category":"page"},{"location":"usage/#WeaklySeparatedCollections.Astar","page":"User guide","title":"WeaklySeparatedCollections.Astar","text":"Astar(root::WSCollection, target::WSCollection)\n\nReturn a sequence of mutations, transforming root into target. This sequence is computed by a the astar algorithm. \n\nKeyword arguments:\n\nheuristic::HEURISTIC = NUMBER_WRONG_LABELS\nlimitSearchSpace::Bool = true\n\nThe available heuristic's are NUMBER_WRONG_LABELS, MIN_LABEL_DIST and MIN_LABEL_DIST_EXPERIMENTAL. If limitSearchSpace is set to true then labels already contained in target will never be mutated.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-9","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\ncheck = checkboard_collection(3, 8)\nrec = rectangle_collection(3, 8)\nAstar(check, rec)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"check = checkboard_collection(4, 9)\nrec = rectangle_collection(4, 9)\nAstar(check, rec, heuristic = MIN_LABEL_DIST_EXPERIMENTAL)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Sometimes we only want to find a sequence of mutations from some WSC to any WSC containing some desired label. ","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"find_label","category":"page"},{"location":"usage/#WeaklySeparatedCollections.find_label","page":"User guide","title":"WeaklySeparatedCollections.find_label","text":"Astar(root::WSCollection, target::WSCollection)\n\nReturns a sequence of mutations, transforming root into a wsc  containing label.\n\nThis sequence is computed by a the astar algorithm. \n\nKeyword arguments:\n\nheuristic::HEURISTIC = NUMBER_WRONG_LABELS\nlimitSearchSpace::Bool = true\n\nThe available heuristic's are NUMBER_WRONG_LABELS, MIN_LABEL_DIST and MIN_LABEL_DIST_EXPERIMENTAL. If limitSearchSpace is set to true then labels already contained in target will never be mutated.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\ncheck = checkboard_collection(4, 9)\nlabel = [2, 3, 4, 9]\ns = find_label(check, label, heuristic = MIN_LABEL_DIST_EXPERIMENTAL)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Lets test the found sequence","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"for i in s\n    mutate!(check, i)\nend\n\ncheck[21] # = label","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Finally to get an overview we can calculate all WSC's of a given type and connect those who arise from each other by mutation by an edge.  The resulting Graph is also called the generalized associahedron.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"generalized_associahedron","category":"page"},{"location":"usage/#WeaklySeparatedCollections.generalized_associahedron","page":"User guide","title":"WeaklySeparatedCollections.generalized_associahedron","text":"generalized_associahedron(root::WSCollection)\n\nreturn all maximal weakly separated collections of same type as root together with a graph that decribes mutations between the wsc's. \n\n\n\n\n\ngeneralized_associahedron(root::WSCollection)\n\nreturn all maximal weakly separated collections of type k, n together with a graph that decribes mutations between the wsc's. \n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"using WeaklySeparatedCollections # hide\nroot = checkboard_collection(3, 7)\nlist, A = generalized_associahedron(root)\nA","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"The obtained Graph may be plottet in 3D using external libraries such as GraphMakie:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"max = length(root) - root.n\nn_mutables = a -> length(get_mutables(list[a]))\nmin = minimum(n_mutables(a) for a in 1:nv(A))\nd = max - min\n\n# greener means more mutable faces, red means less mutable faces.\nnode_colors = [RGBA(1.0 - (n_mutables(a) - min)/d, (n_mutables(a) - min)/d, 0.0, 1.0) \n                for a in 1:nv(A)]\n\ngraphplot(A, layout = Spring(dim = 3, seed = 1), edge_width = 0.5, node_size = 15, \n            node_color = node_colors)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/#Plotting","page":"User guide","title":"Plotting","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Plotting WSC's requires Luxor to be installed and loaded as detailed here.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"In the introduction we learned about plabic tilings as well as plabic graphs as objects living in the plane which are in one to one correspondance to maximal WSC's. Thus we can plot a maximal WSC using its corresponding plabic tiling or plabic graph. The functions to accomplish this are:","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"drawTiling","category":"page"},{"location":"usage/#WeaklySeparatedCollections.drawTiling","page":"User guide","title":"WeaklySeparatedCollections.drawTiling","text":"drawTiling(collection::WSCollection, title::String, width::Int = 500, height::Int = 500)\n\nDraw the plabic tiling of the provided weakly separated collection and save it as an  image file of specified size.  Both the name as well as the resulting file type of the image are controlled via title.\n\nInside a Jupyter sheet drawing without saving an image is possible by omitting the title argument i.e. via drawTiling(collection::WSCollection, width::Int = 500, height::Int = 500).\n\nKeyword Arguments\n\ntopLabel = nothing\nbackgroundColor::Union{String, ColorTypes.Colorant} = \"\"\ndrawLabels::Bool = true\nhighlightMutables::Bool = true\nlabelDirection = \"left\"\n\ntoplabel controls the rotation of the drawing by drawing the specified label at the top. labelDirection controls whether the \"left\" (i.e. the usual ones) or \"right\" (complements) labels are drawn.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"drawPLG","category":"page"},{"location":"usage/#WeaklySeparatedCollections.drawPLG","page":"User guide","title":"WeaklySeparatedCollections.drawPLG","text":"drawPLG(collection::WSCollection, title::String, width::Int = 500, height::Int = 500)\n\nDraw the plabic graph of the provided weakly separated collection and save it as an  image file of specified size. Both the name as well as the resulting file type of the image are controlled via title.\n\nInside a Jupyter sheet drawing without saving an image is possible by omitting the title argument i.e. via drawPLG(collection::WSCollection, width::Int = 500, height::Int = 500). \n\nKeyword Arguments\n\ntopLabel = nothing\ndrawmode::String = \"straight\"\nbackgroundColor::Union{String, ColorTypes.Colorant} = \"\"\ndrawLabels::Bool = true\nhighlightMutables::Bool = false\nlabelDirection = \"left\"\n\ntoplabel controls the rotation of the drawing by drawing the specified label at the top. drawmode controls how edges are drawn and may be choosen as \"straight\", \"smooth\" or \"polygonal\". labelDirection controls whether the \"left\" (i.e. the usual ones) or \"right\" (complements) labels  are drawn.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Examples:-10","page":"User guide","title":"Examples:","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"If working in a Jupyter sheet, WSC's may be plottet directly without saving the image in a file.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"H = rectangle_collection(3, 6)\ndrawTiling(H) # plotts H as plabic tiling","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"H = rectangle_collection(3, 6)\ndrawPLG_straight(H; drawLabels = true) # plotts H as plabic graph with straight edges","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"To save an image as png, svg, pdf or eps file, we just need to give it a title with the corresponding file extension.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"H = checkboard_collection(3, 6)\n# will save the image as title.png (by defalut without background)\ndrawPLG_straight(H, \"title.png\"; drawLabels = true)","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/#Graphical-user-interface","page":"User guide","title":"Graphical user interface","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"The graphical user interface requires both an installation of Luxor as well as Mousetrap. See here for details.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"While plotting WSC's enables us to visualize them, the resulting images lack interactivity. This is where the built in gui application comes in handy. To start it we use","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"visualizer!","category":"page"},{"location":"usage/#WeaklySeparatedCollections.visualizer!","page":"User guide","title":"WeaklySeparatedCollections.visualizer!","text":"visualizer!(collection::WSCollection = rectangle_collection(4, 9))\n\nStart the graphical user interface to visualize the provided collection.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Much of the functionality discussed so far is available through this interface, for example to mutate a WSC in the direction of a label we can just click on it.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"We shortly explain the contend of the menubar as well as settings.","category":"page"},{"location":"usage/#Settings","page":"User guide","title":"Settings","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Draw mode controls how edges of the plabic graph are drwn. The available modes are Straight, Smooth and Polygonal\nLabel direction controls whether the left (i.e. the usual ones) or right labels (complements of left labels) are drawn.\nDraw vertex labels controls if the labels in the plabic tiling should be drawn or not.\nDraw face labels controls whether the labels in the plabic graph are drawn or not.\nadjust top label if checked then a the boundary label of the plabic graph that should be drawn at the top can be chosen through the slider below. This adjusts both the embedding of the plabic graph as well as the corresponding tiling.","category":"page"},{"location":"usage/#File","page":"User guide","title":"File","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Through the File submenu we may save or load WSC's. ","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"Moreover we can also easily export the images drawn in the gui as png, svg, pdf or eps file","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/#Edit","page":"User guide","title":"Edit","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"The Edit submenu contains transformations other than mutation, such as rotations and reflections as well as a quick way to load all the predefines WSC's.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/#View","page":"User guide","title":"View","text":"","category":"section"},{"location":"usage/","page":"User guide","title":"User guide","text":"Finally under the view submenu all options to disable/enable parts of the gui are collected.","category":"page"},{"location":"usage/","page":"User guide","title":"User guide","text":"(Image: )","category":"page"},{"location":"usage/#Oscar-extension","page":"User guide","title":"Oscar extension","text":"","category":"section"},{"location":"reference/","page":"References","title":"References","text":"TODO: insert references to literature here.","category":"page"},{"location":"#WeaklySeparatedCollections","page":"Home","title":"WeaklySeparatedCollections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In its core, this package implements the combinatorics of weakly separated collections. It also provides optional tools for plotting as well an intuitive graphical user interface.","category":"page"},{"location":"#How-to-install","page":"Home","title":"How to install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is divided into severaral parts. The base package implements only the combinatorics while several optional extensions can be loaded to enable additional features such as plotting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the package execute the following in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg;\nPkg.add(url=\"https://github.com/MichaelSchloesser/WeaklySeparatedCollections.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package may then be used as usual via","category":"page"},{"location":"","page":"Home","title":"Home","text":"using WeaklySeparatedCollections","category":"page"},{"location":"#Extensions","page":"Home","title":"Extensions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To enable extensions Julia v1.9 or newer, as well as some additional packages need to be installed.","category":"page"},{"location":"#Plotting","page":"Home","title":"Plotting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use this feature, Luxor needs to be installed. In the Julia REPL simply execute:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg;\nPkg.add(\"Luxor\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now load both WeaklySeparatedCollections and Luxor to activate the plotting extension:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using WeaklySeparatedCollections\nimport Luxor ","category":"page"},{"location":"#GUI","page":"Home","title":"GUI","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use the graphical user interface, Luxor and Mousetrap are required. Installing Luxor is explained in the previous section. To install Mousetrap run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg;\nPkg.add(url=\"https://github.com/clemapfel/mousetrap.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now loading all of WeaklySeparatedCollections, Luxor and Mousetrap will activate the gui extension.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using WeaklySeparatedCollections\nimport Luxor\nimport Mousetrap","category":"page"},{"location":"#Oscar","page":"Home","title":"Oscar","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We extend some functionality of Oscar and add methods to handle the A-cluster mutation of Seeds coming from weakly separated collections as well as the associated newton-okounkov-bodies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This extension is only supported for Linux users (although Windows users may use Linux from Windows via wsl). We refer to the official Oscar website for details of the installation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Afterward using the loading the extension is as simple as typing","category":"page"},{"location":"","page":"Home","title":"Home","text":"using WeaklySeparatedCollections\nusing Oscar","category":"page"}]
}
